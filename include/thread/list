
#pragma once

#include <list>

#include <mutex>
#include <thread>

namespace std {

template <typename _Ty, class _Alloc = allocator<_Ty>>
class thread_list {
public:
  typedef thread_list<_Ty> _Myt;
  typedef list<_Ty> _Mybase;
  typedef typename _Mybase::_Node _Node;
  typedef typename _Mybase::_Nodeptr _Nodeptr;
  typedef typename _Mybase::_Alty _Alty;

  typedef _Alloc allocator_type;
  typedef typename _Mybase::size_type size_type;
  typedef typename _Mybase::difference_type difference_type;
  typedef typename _Mybase::pointer pointer;
  typedef typename _Mybase::const_pointer const_pointer;
  typedef typename _Mybase::reference reference;
  typedef typename _Mybase::const_reference const_reference;
  typedef typename _Mybase::value_type value_type;

  typedef typename _Mybase::const_iterator const_iterator;
  typedef typename _Mybase::iterator iterator;
  typedef typename _Mybase::_Unchecked_const_iterator _Unchecked_const_iterator;
  typedef typename _Mybase::_Unchecked_iterator _Unchecked_iterator;

  typedef _STD reverse_iterator<iterator> reverse_iterator;
  typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;

  thread_list() : _base() {}
  thread_list(_Myt const & _Right) = delete;
  thread_list(_Mybase const & _Right) = delete;
  _Myt & operator=(_Mybase const & _Right) = delete;

  void push_back(_Ty && _Val) {
    // while (_base.size() > 10) { wait(); }
    _mutex.lock();
    _base.push_back(_Val);
    _mutex.unlock();
  }
  void push_back(_Ty const & _Val) {
    // while (_base.size() > 10) { wait(); }
    _mutex.lock();
    _base.push_back(_Val);
    _mutex.unlock();
  }

  reference front() {
    while (_base.empty()) { wait(); }
    return _base.front();
  }
  const_reference front() const {
    while (_base.empty()) { wait(); }
    return _base.front();
  }

  void pop_front() {
    while (_base.empty()) { wait(); }
    _mutex.lock();
    _base.pop_front();
    _mutex.unlock();
  }

  size_type size() const {
    return _base.size();
  }

private:
  void wait() {
    // this_thread::sleep_for(chrono::milliseconds(100));
    this_thread::yield();
  }

  _Mybase _base;
  mutex _mutex;
};

} // namespace std
